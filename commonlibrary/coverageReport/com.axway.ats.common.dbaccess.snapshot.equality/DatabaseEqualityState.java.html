<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>DatabaseEqualityState.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">ATS-CommonLibrary</a> &gt; <a href="index.source.html" class="el_package">com.axway.ats.common.dbaccess.snapshot.equality</a> &gt; <span class="el_source">DatabaseEqualityState.java</span></div><h1>DatabaseEqualityState.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2017-2020 Axway Software
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.axway.ats.common.dbaccess.snapshot.equality;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.TreeMap;

import com.axway.ats.common.PublicAtsApi;

/**
 * This structure says how equal the snapshots are
 */
@PublicAtsApi
public class DatabaseEqualityState {

	private String firstSnapshotName;

	private String secondSnapshotName;

	// &lt;snapshot, table&gt; we are using TreeMap in order to use save order regardless of the
	// JDK
<span class="nc" id="L37">	private Map&lt;String, List&lt;String&gt;&gt; tablePresentInOneSnapshotOnly = new TreeMap&lt;&gt;();</span>

	// list of primary key columns which are different for same table in both snapshots
	// NOTE: currently we do not support more than one primary key per table
	// &lt; snapshot, &lt; table, key &gt; &gt;
<span class="nc" id="L42">	private Map&lt;String, Map&lt;String, String&gt;&gt; differentPrimaryKeys = new TreeMap&lt;&gt;();</span>

	// list tables with different size
	// &lt; snapshot, &lt; table, number of rows &gt; &gt;
<span class="nc" id="L46">	private Map&lt;String, Map&lt;String, Integer&gt;&gt; differentNumberOfRows = new TreeMap&lt;&gt;();</span>

	// &lt;snapshot &lt;table, row values&gt;&gt; we are using TreeMap in order to use save order
	// regardless of the JDK
<span class="nc" id="L50">	private Map&lt;String, Map&lt;String, List&lt;String&gt;&gt;&gt; rowPresentInOneSnapshotOnly = new TreeMap&lt;&gt;();</span>

	// &lt;snapshot &lt;table, &lt;columns&gt; &gt;&gt; we are using TreeMap in order to use save order
	// regardless of the JDK
<span class="nc" id="L54">	private Map&lt;String, Map&lt;String, List&lt;String&gt;&gt;&gt; columnPresentInOneSnapshotOnly = new TreeMap&lt;&gt;();</span>

	// &lt;snapshot &lt;table, &lt;indexes&gt; &gt;&gt; we are using TreeMap in order to use save order
	// regardless of the JDK
<span class="nc" id="L58">	private Map&lt;String, Map&lt;String, List&lt;String&gt;&gt;&gt; indexPresentInOneSnapshotOnly = new TreeMap&lt;&gt;();</span>

<span class="nc" id="L60">	public DatabaseEqualityState(String firstSnapshotName, String secondSnapshotName) {</span>

<span class="nc" id="L62">		this.firstSnapshotName = firstSnapshotName;</span>
<span class="nc" id="L63">		this.secondSnapshotName = secondSnapshotName;</span>
<span class="nc" id="L64">	}</span>

	/**
	 * @return the name of the first snapshot
	 */
	@PublicAtsApi
	public String getFirstSnapshotName() {

<span class="nc" id="L72">		return firstSnapshotName;</span>
	}

	/**
	 * @return the name of the second snapshot
	 */
	@PublicAtsApi
	public String getSecondSnapshotName() {

<span class="nc" id="L81">		return secondSnapshotName;</span>
	}

	/**
	 * @return whether some differences are found
	 */
	@PublicAtsApi
	public boolean hasDifferences() {

<span class="nc bnc" id="L90" title="All 4 branches missed.">		return tablePresentInOneSnapshotOnly.size() &gt; 0 || differentPrimaryKeys.size() &gt; 0</span>
<span class="nc bnc" id="L91" title="All 4 branches missed.">				|| differentNumberOfRows.size() &gt; 0 || rowPresentInOneSnapshotOnly.size() &gt; 0</span>
<span class="nc bnc" id="L92" title="All 4 branches missed.">				|| columnPresentInOneSnapshotOnly.size() &gt; 0 || indexPresentInOneSnapshotOnly.size() &gt; 0;</span>
	}

	/**
	 * @param snapshot snapshot name
	 * @return tables present in one snapshot only
	 */
	@PublicAtsApi
	public List&lt;String&gt; getTablesPresentInOneSnapshotOnly(String snapshot) {

<span class="nc" id="L102">		List&lt;String&gt; tablesPerSnapshot = tablePresentInOneSnapshotOnly.get(snapshot);</span>
		;
<span class="nc bnc" id="L104" title="All 2 branches missed.">		if (tablesPerSnapshot == null) {</span>
<span class="nc" id="L105">			tablesPerSnapshot = new ArrayList&lt;String&gt;();</span>
		}

<span class="nc" id="L108">		return tablesPerSnapshot;</span>
	}

	public void addTablePresentInOneSnapshotOnly(String snapshotName, String table) {

<span class="nc" id="L113">		List&lt;String&gt; tablesPerSnapshot = tablePresentInOneSnapshotOnly.get(snapshotName);</span>
<span class="nc bnc" id="L114" title="All 2 branches missed.">		if (tablesPerSnapshot == null) {</span>
<span class="nc" id="L115">			tablesPerSnapshot = new ArrayList&lt;String&gt;();</span>
<span class="nc" id="L116">			tablePresentInOneSnapshotOnly.put(snapshotName, tablesPerSnapshot);</span>
		}

<span class="nc" id="L119">		tablesPerSnapshot.add(table);</span>
<span class="nc" id="L120">	}</span>

	/**
	 * Get list of tables with different primary keys &lt;br&gt;
	 * Note that the list of tables is the same for both snapshots
	 * @param snapshot snapshot name
	 * @return tables with different primary keys
	 */
	@PublicAtsApi
	public List&lt;String&gt; getTablesWithDifferentPrimaryKeys(String snapshot) {

<span class="nc" id="L131">		List&lt;String&gt; tables = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L132" title="All 2 branches missed.">		if (differentPrimaryKeys.containsKey(snapshot)) {</span>
<span class="nc" id="L133">			tables.addAll(differentPrimaryKeys.get(snapshot).keySet());</span>
		}

<span class="nc" id="L136">		return tables;</span>
	}

	/**
	 * Get the different primary keys per table and snapshot. &lt;br&gt;
	 * Note that we currently do not support more than one primary key difference
	 * @param snapshot snapshot name
	 * @param table table name
	 * @return the different primary keys
	 */
	@PublicAtsApi
	public String getDifferentPrimaryKeys(String snapshot, String table) {

<span class="nc" id="L149">		String primaryKey = null;</span>

<span class="nc" id="L151">		Map&lt;String, String&gt; keysPerTable = differentPrimaryKeys.get(snapshot);</span>
<span class="nc bnc" id="L152" title="All 2 branches missed.">		if (keysPerTable != null) {</span>
<span class="nc" id="L153">			primaryKey = keysPerTable.get(table);</span>
		}

<span class="nc bnc" id="L156" title="All 2 branches missed.">		return primaryKey != null ? primaryKey : &quot;&quot;;</span>
	}

	public void addDifferentPrimaryKeys(String firstSnapshotName, String secondSnapshotName, String firstPrimaryKey,
			String secondPrimaryKey, String table) {

<span class="nc" id="L162">		addDifferentPrimaryKey(firstSnapshotName, firstPrimaryKey, table);</span>
<span class="nc" id="L163">		addDifferentPrimaryKey(secondSnapshotName, secondPrimaryKey, table);</span>
<span class="nc" id="L164">	}</span>

	private void addDifferentPrimaryKey(String snapshot, String primaryKey, String table) {

<span class="nc" id="L168">		Map&lt;String, String&gt; _differentPrimaryKeys = differentPrimaryKeys.get(snapshot);</span>
<span class="nc bnc" id="L169" title="All 2 branches missed.">		if (_differentPrimaryKeys == null) {</span>
<span class="nc" id="L170">			_differentPrimaryKeys = new TreeMap&lt;&gt;();</span>
<span class="nc" id="L171">			differentPrimaryKeys.put(snapshot, _differentPrimaryKeys);</span>
		}
<span class="nc" id="L173">		_differentPrimaryKeys.put(table, primaryKey);</span>
<span class="nc" id="L174">	}</span>

	/**
	 * Get list of tables with different number of rows &lt;br&gt;
	 * Note that the list of tables is the same for both snapshots
	 * @param snapshot snapshot name
	 * @return tables with different number of rows
	 */
	@PublicAtsApi
	public List&lt;String&gt; getTablesWithDifferentNumberOfRows(String snapshot) {

<span class="nc" id="L185">		List&lt;String&gt; tables = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L186" title="All 2 branches missed.">		if (differentNumberOfRows.containsKey(snapshot)) {</span>
<span class="nc" id="L187">			tables.addAll(differentNumberOfRows.get(snapshot).keySet());</span>
		}

<span class="nc" id="L190">		return tables;</span>
	}

	/**
	 * Get the number of rows for the given table and snapshot. &lt;br&gt;
	 * @param snapshot snapshot name
	 * @param table table name
	 * @return number of rows
	 */
	@PublicAtsApi
	public Integer getDifferentNumberOfRows(String snapshot, String table) {

<span class="nc" id="L202">		Integer numberRows = null;</span>

<span class="nc" id="L204">		Map&lt;String, Integer&gt; numberRowsPerTable = differentNumberOfRows.get(snapshot);</span>
<span class="nc bnc" id="L205" title="All 2 branches missed.">		if (numberRowsPerTable != null) {</span>
<span class="nc" id="L206">			numberRows = numberRowsPerTable.get(table);</span>
		}

<span class="nc" id="L209">		return numberRows;</span>
	}

	public void addDifferentNumberOfRows(String firstSnapshotName, String secondSnapshotName, int firstNumberOfRows,
			int secondNumberOfRows, String table) {

<span class="nc" id="L215">		addDifferentNumberOfRows(firstSnapshotName, table, firstNumberOfRows);</span>
<span class="nc" id="L216">		addDifferentNumberOfRows(secondSnapshotName, table, secondNumberOfRows);</span>
<span class="nc" id="L217">	}</span>

	private void addDifferentNumberOfRows(String snapshot, String table, Integer numberOfRows) {

<span class="nc" id="L221">		Map&lt;String, Integer&gt; _differentNumberOfRows = differentNumberOfRows.get(snapshot);</span>
<span class="nc bnc" id="L222" title="All 2 branches missed.">		if (_differentNumberOfRows == null) {</span>
<span class="nc" id="L223">			_differentNumberOfRows = new TreeMap&lt;&gt;();</span>
<span class="nc" id="L224">			differentNumberOfRows.put(snapshot, _differentNumberOfRows);</span>
		}
<span class="nc" id="L226">		_differentNumberOfRows.put(table, numberOfRows);</span>
<span class="nc" id="L227">	}</span>

	/**
	 * Get list of tables with unique columns &lt;br&gt;
	 * @param snapshot snapshot name
	 * @return tables with unique columns
	 */
	@PublicAtsApi
	public List&lt;String&gt; getTablesWithColumnsPresentInOneSnapshotOnly(String snapshot) {

<span class="nc" id="L237">		return breakIntoTables(columnPresentInOneSnapshotOnly, snapshot);</span>
	}

	/**
	 * Get a list of unique columns for the given table and snapshot. &lt;br&gt;
	 *
	 * We return a list each item of which represents a column description. The list
	 * contains a map where the key is a column attribute name while the value is a column
	 * attribute value.
	 * @param snapshot snapshot name
	 * @param table table name
	 * @return list of unique columns
	 */
	@PublicAtsApi
	public List&lt;Map&lt;String, String&gt;&gt; getColumnsPresentInOneSnapshotOnly(String snapshot, String table) {

<span class="nc" id="L253">		return breakIntoEntityAttributes(columnPresentInOneSnapshotOnly, snapshot, table, &quot;, &quot;);</span>
	}

	/**
	 * Get a list of unique columns for the given table and snapshot. &lt;br&gt;
	 *
	 * We return a list each item of which is a String describing a column.
	 * @param snapshot snapshot name
	 * @param table table name
	 * @return list of unique columns
	 */
	@PublicAtsApi
	public List&lt;String&gt; getColumnsPresentInOneSnapshotOnlyAsStrings(String snapshot, String table) {

<span class="nc" id="L267">		List&lt;String&gt; result = new ArrayList&lt;&gt;();</span>

<span class="nc" id="L269">		Map&lt;String, List&lt;String&gt;&gt; columnsPerTable = columnPresentInOneSnapshotOnly.get(snapshot);</span>
<span class="nc bnc" id="L270" title="All 2 branches missed.">		if (columnsPerTable != null) {</span>
<span class="nc" id="L271">			result = columnsPerTable.get(table);</span>
		}

<span class="nc" id="L274">		return result;</span>
	}

	public void addColumnPresentInOneSnapshotOnly(String snapshotName, String table, String column) {

<span class="nc" id="L279">		Map&lt;String, List&lt;String&gt;&gt; tablesPerSnapshot = columnPresentInOneSnapshotOnly.get(snapshotName);</span>
<span class="nc bnc" id="L280" title="All 2 branches missed.">		if (tablesPerSnapshot == null) {</span>
<span class="nc" id="L281">			tablesPerSnapshot = new TreeMap&lt;&gt;();</span>
<span class="nc" id="L282">			columnPresentInOneSnapshotOnly.put(snapshotName, tablesPerSnapshot);</span>
		}

<span class="nc" id="L285">		List&lt;String&gt; columnsPerTable = tablesPerSnapshot.get(table);</span>
<span class="nc bnc" id="L286" title="All 2 branches missed.">		if (columnsPerTable == null) {</span>
<span class="nc" id="L287">			columnsPerTable = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L288">			tablesPerSnapshot.put(table, columnsPerTable);</span>
		}

<span class="nc" id="L291">		columnsPerTable.add(column);</span>
<span class="nc" id="L292">	}</span>

	/**
	 * Get list of tables with unique indexes &lt;br&gt;
	 * @param snapshot snapshot name
	 * @return tables with unique indexes
	 */
	@PublicAtsApi
	public List&lt;String&gt; getTablesWithIndexesPresentInOneSnapshotOnly(String snapshot) {

<span class="nc" id="L302">		return breakIntoTables(indexPresentInOneSnapshotOnly, snapshot);</span>
	}

	/**
	 * Get a list of unique indexes for the given table and snapshot. &lt;br&gt;
	 *
	 * We return a list each item of which represents an index description. The list
	 * contains a map where the key is an index attribute name while the value is an index
	 * attribute value.
	 * @param snapshot snapshot name
	 * @param table table name
	 * @return list of unique indexes
	 */
	@PublicAtsApi
	public List&lt;Map&lt;String, String&gt;&gt; getIndexesPresentInOneSnapshotOnly(String snapshot, String table) {

<span class="nc" id="L318">		return breakIntoEntityAttributes(indexPresentInOneSnapshotOnly, snapshot, table, &quot;, &quot;);</span>
	}

	/**
	 * Get a list of unique indexes for the given table and snapshot. &lt;br&gt;
	 *
	 * We return a list each item of which is a String describing an index.
	 * @param snapshot snapshot name
	 * @param table table name
	 * @return list of unique indexes
	 */
	@PublicAtsApi
	public List&lt;String&gt; getIndexesPresentInOneSnapshotOnlyAsStrings(String snapshot, String table) {

<span class="nc" id="L332">		List&lt;String&gt; result = null;</span>

<span class="nc" id="L334">		Map&lt;String, List&lt;String&gt;&gt; indexesPerTable = indexPresentInOneSnapshotOnly.get(snapshot);</span>
<span class="nc bnc" id="L335" title="All 2 branches missed.">		if (indexesPerTable != null) {</span>
<span class="nc" id="L336">			result = indexesPerTable.get(table);</span>
		}

<span class="nc bnc" id="L339" title="All 2 branches missed.">		if (result == null) {</span>
			// no indexes for that table, so return empty list
<span class="nc" id="L341">			result = new ArrayList&lt;&gt;();</span>
		}

<span class="nc" id="L344">		return result;</span>
	}

	public void addIndexPresentInOneSnapshotOnly(String snapshotName, String table, String indexName, String index) {

<span class="nc" id="L349">		Map&lt;String, List&lt;String&gt;&gt; tablesPerSnapshot = indexPresentInOneSnapshotOnly.get(snapshotName);</span>
<span class="nc bnc" id="L350" title="All 2 branches missed.">		if (tablesPerSnapshot == null) {</span>
<span class="nc" id="L351">			tablesPerSnapshot = new TreeMap&lt;&gt;();</span>
<span class="nc" id="L352">			indexPresentInOneSnapshotOnly.put(snapshotName, tablesPerSnapshot);</span>
		}

<span class="nc" id="L355">		List&lt;String&gt; indexesPerTable = tablesPerSnapshot.get(table);</span>
<span class="nc bnc" id="L356" title="All 2 branches missed.">		if (indexesPerTable == null) {</span>
<span class="nc" id="L357">			indexesPerTable = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L358">			tablesPerSnapshot.put(table, indexesPerTable);</span>
		}

<span class="nc" id="L361">		indexesPerTable.add(indexName + &quot;, &quot; + index);</span>
<span class="nc" id="L362">	}</span>

	/**
	 * Get list of tables with unique rows &lt;br&gt;
	 * @param snapshot snapshot name
	 * @return tables with unique rows
	 */
	@PublicAtsApi
	public List&lt;String&gt; getTablesWithRowsPresentInOneSnapshotOnly(String snapshot) {

<span class="nc" id="L372">		return breakIntoTables(rowPresentInOneSnapshotOnly, snapshot);</span>
	}

	/**
	 * Get a list of unique rows for the given table and snapshot. &lt;br&gt;
	 *
	 * We return a list each item of which represents a row. The list contains a map where
	 * the key is a column name while the value is a value at that column of the row.
	 * @param snapshot snapshot name
	 * @param table table name
	 * @return list of unique rows
	 */
	@PublicAtsApi
	public List&lt;Map&lt;String, String&gt;&gt; getRowsPresentInOneSnapshotOnly(String snapshot, String table) {

<span class="nc" id="L387">		return breakIntoEntityAttributes(rowPresentInOneSnapshotOnly, snapshot, table, &quot;\\|&quot;);</span>
	}

	/**
	 * Get a list of unique rows for the given table and snapshot. &lt;br&gt;
	 *
	 * We return a list each item of which is a String describing the row content.
	 * @param snapshot snapshot name
	 * @param table table name
	 * @return list of unique indexes
	 */
	@PublicAtsApi
	public List&lt;String&gt; getRowsPresentInOneSnapshotOnlyAsStrings(String snapshot, String table) {

<span class="nc" id="L401">		List&lt;String&gt; result = new ArrayList&lt;&gt;();</span>

<span class="nc" id="L403">		Map&lt;String, List&lt;String&gt;&gt; rowsPerTable = rowPresentInOneSnapshotOnly.get(snapshot);</span>
<span class="nc bnc" id="L404" title="All 2 branches missed.">		if (rowsPerTable != null) {</span>
<span class="nc" id="L405">			result = rowsPerTable.get(table);</span>
		}

<span class="nc" id="L408">		return result;</span>
	}

	public void addRowPresentInOneSnapshotOnly(String snapshotName, String table, String rowValues) {

<span class="nc" id="L413">		Map&lt;String, List&lt;String&gt;&gt; tablesPerSnapshot = rowPresentInOneSnapshotOnly.get(snapshotName);</span>
<span class="nc bnc" id="L414" title="All 2 branches missed.">		if (tablesPerSnapshot == null) {</span>
<span class="nc" id="L415">			tablesPerSnapshot = new TreeMap&lt;&gt;();</span>
<span class="nc" id="L416">			rowPresentInOneSnapshotOnly.put(snapshotName, tablesPerSnapshot);</span>
		}

<span class="nc" id="L419">		List&lt;String&gt; rowsPerTable = tablesPerSnapshot.get(table);</span>
<span class="nc bnc" id="L420" title="All 2 branches missed.">		if (rowsPerTable == null) {</span>
<span class="nc" id="L421">			rowsPerTable = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L422">			tablesPerSnapshot.put(table, rowsPerTable);</span>
		}

<span class="nc" id="L425">		rowsPerTable.add(rowValues);</span>
<span class="nc" id="L426">	}</span>

	public void clearDifferentNumberOfRowsForTable(String tableName) {

		// check if the table have different rows
<span class="nc bnc" id="L431" title="All 2 branches missed.">		if (this.getDifferentNumberOfRows(firstSnapshotName, tableName) != null) {</span>
<span class="nc" id="L432">			this.differentNumberOfRows.get(firstSnapshotName).remove(tableName);</span>
<span class="nc bnc" id="L433" title="All 2 branches missed.">			if (this.differentNumberOfRows.get(firstSnapshotName) == null</span>
<span class="nc bnc" id="L434" title="All 2 branches missed.">					|| this.differentNumberOfRows.get(firstSnapshotName).isEmpty()) {</span>
<span class="nc" id="L435">				this.differentNumberOfRows.remove(firstSnapshotName);</span>
			}
		}
<span class="nc bnc" id="L438" title="All 2 branches missed.">		if (this.getDifferentNumberOfRows(secondSnapshotName, tableName) != null) {</span>
<span class="nc" id="L439">			this.differentNumberOfRows.get(secondSnapshotName).remove(tableName);</span>
<span class="nc bnc" id="L440" title="All 2 branches missed.">			if (this.differentNumberOfRows.get(secondSnapshotName) == null</span>
<span class="nc bnc" id="L441" title="All 2 branches missed.">					|| this.differentNumberOfRows.get(secondSnapshotName).isEmpty()) {</span>
<span class="nc" id="L442">				this.differentNumberOfRows.remove(secondSnapshotName);</span>
			}
		}
<span class="nc" id="L445">	}</span>

	public void clearRowsPresentedInOneSnapshotOnly(String tableName) {

<span class="nc bnc" id="L449" title="All 2 branches missed.">		if (this.rowPresentInOneSnapshotOnly.containsKey(firstSnapshotName)) {</span>
<span class="nc bnc" id="L450" title="All 2 branches missed.">			if (this.rowPresentInOneSnapshotOnly.get(firstSnapshotName).containsKey(tableName)) {</span>
<span class="nc" id="L451">				this.rowPresentInOneSnapshotOnly.get(firstSnapshotName).remove(tableName);</span>
<span class="nc bnc" id="L452" title="All 2 branches missed.">				if (this.rowPresentInOneSnapshotOnly.get(firstSnapshotName) == null</span>
<span class="nc bnc" id="L453" title="All 2 branches missed.">						|| this.rowPresentInOneSnapshotOnly.get(firstSnapshotName).isEmpty()) {</span>
<span class="nc" id="L454">					this.rowPresentInOneSnapshotOnly.remove(firstSnapshotName);</span>
				}
			}
		}

<span class="nc bnc" id="L459" title="All 2 branches missed.">		if (this.rowPresentInOneSnapshotOnly.containsKey(secondSnapshotName)) {</span>
<span class="nc bnc" id="L460" title="All 2 branches missed.">			if (this.rowPresentInOneSnapshotOnly.get(secondSnapshotName).containsKey(tableName)) {</span>
<span class="nc" id="L461">				this.rowPresentInOneSnapshotOnly.get(secondSnapshotName).remove(tableName);</span>
<span class="nc bnc" id="L462" title="All 2 branches missed.">				if (this.rowPresentInOneSnapshotOnly.get(secondSnapshotName) == null</span>
<span class="nc bnc" id="L463" title="All 2 branches missed.">						|| this.rowPresentInOneSnapshotOnly.get(secondSnapshotName).isEmpty()) {</span>
<span class="nc" id="L464">					this.rowPresentInOneSnapshotOnly.remove(secondSnapshotName);</span>
				}
			}
		}
<span class="nc" id="L468">	}</span>

	private List&lt;String&gt; breakIntoTables(Map&lt;String, Map&lt;String, List&lt;String&gt;&gt;&gt; entities, String snapshot) {

<span class="nc" id="L472">		List&lt;String&gt; tables = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L473" title="All 2 branches missed.">		if (entities.containsKey(snapshot)) {</span>
<span class="nc" id="L474">			tables.addAll(entities.get(snapshot).keySet());</span>
		}

<span class="nc" id="L477">		return tables;</span>
	}

	private List&lt;Map&lt;String, String&gt;&gt; breakIntoEntityAttributes(Map&lt;String, Map&lt;String, List&lt;String&gt;&gt;&gt; entities,
			String snapshot, String table, String delimeter) {

<span class="nc" id="L483">		List&lt;Map&lt;String, String&gt;&gt; result = new ArrayList&lt;&gt;();</span>

<span class="nc" id="L485">		Map&lt;String, List&lt;String&gt;&gt; entitiesPerTable = entities.get(snapshot);</span>
<span class="nc bnc" id="L486" title="All 2 branches missed.">		if (entitiesPerTable != null) {</span>
<span class="nc" id="L487">			List&lt;String&gt; allEntitiesAsStrings = entitiesPerTable.get(table);</span>

<span class="nc bnc" id="L489" title="All 2 branches missed.">			if (allEntitiesAsStrings == null) {</span>
				// no entries for the provided table in the provided snapshot
<span class="nc" id="L491">				return result;</span>
			}

			// cycle all entities
<span class="nc bnc" id="L495" title="All 2 branches missed.">			for (String entityAsString : allEntitiesAsStrings) {</span>
<span class="nc" id="L496">				String[] entityAttributesAsString = entityAsString.split(delimeter);</span>

				// cycle all attributes of one entity
<span class="nc" id="L499">				Map&lt;String, String&gt; attributes = new TreeMap&lt;&gt;();</span>
<span class="nc bnc" id="L500" title="All 2 branches missed.">				for (String entityAttributeAsString : entityAttributesAsString) {</span>
<span class="nc" id="L501">					String[] attributeTokens = entityAttributeAsString.split(&quot;=&quot;);</span>
<span class="nc bnc" id="L502" title="All 2 branches missed.">					if (attributeTokens.length == 2) {</span>
<span class="nc" id="L503">						attributes.put(attributeTokens[0], attributeTokens[1]);</span>
					}
					else {
						// expecting just key without a value
<span class="nc" id="L507">						attributes.put(attributeTokens[0], &quot;&quot;);</span>
					}
				}
<span class="nc" id="L510">				result.add(attributes);</span>
<span class="nc" id="L511">			}</span>
		}

<span class="nc" id="L514">		return result;</span>
	}

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>